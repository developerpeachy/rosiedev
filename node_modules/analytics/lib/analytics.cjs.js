'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var redux = require('redux');
var analyticsUtils = require('analytics-utils');

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

var coreEvents = [
/**
 * `bootstrap` - Fires when analytics library starts up.
 * This is the first event fired. '.on/once' listeners are not allowed on bootstrap
 * Plugins can attach logic to this event
 */
'bootstrap',
/**
 * `params` - Fires when analytics parses URL parameters
 */
'params',
/**
 * `campaign` - Fires if params contain "utm" parameters
 */
'campaign',
/**
 * `initializeStart` - Fires before 'initialize', allows for plugins to cancel loading of other plugins
 */
'initializeStart',
/**
 * `initialize` - Fires when analytics loads plugins
 */
'initialize',
/**
 * `initializeEnd` - Fires after initialize, allows for plugins to run logic after initialization methods run
 */
'initializeEnd',
/**
 * `ready` - Fires when all analytic providers are fully loaded. This waits for 'initialize' and 'loaded' to return true
 */
'ready',
/**
 * `resetStart` - Fires if analytic.reset() is called.
 * Use this event to cancel reset based on a specific condition
 */
'resetStart',
/**
 * `reset` - Fires if analytic.reset() is called.
 * Use this event to run custom cleanup logic (if needed)
 */
'reset',
/**
 * `resetEnd` - Fires after analytic.reset() is called.
 * Use this event to run a callback after user data is reset
 */
'resetEnd',
/******************
 * Page Events
 ******************/

/**
 * `pageStart` - Fires before 'page' events fire.
 *  This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'pageStart',
/**
 * `page` - Core analytics hook for page views.
 *  If your plugin or integration tracks page views, this is the event to fire on.
 */
'page',
/**
 * `pageEnd` - Fires after all registered 'page' methods fire.
 */
'pageEnd',
/**
 * `pageAborted` - Fires if 'page' call is cancelled by a plugin
 */
'pageAborted',
/****************
 * Track Events
 ***************/

/**
 * `trackStart` - Called before the 'track' events fires.
 *  This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'trackStart',
/**
 * `track` - Core analytics hook for event tracking.
 *  If your plugin or integration tracks custom events, this is the event to fire on.
 */
'track',
/**
 * `trackEnd` - Fires after all registered 'track' events fire from plugins.
 */
'trackEnd',
/**
 * `trackAborted` - Fires if 'track' call is cancelled by a plugin
 */
'trackAborted',
/******************
 * Identify Events
 ******************/

/**
 * `identifyStart` - Called before the 'identify' events fires.
 * This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'identifyStart',
/**
 * `identify` - Core analytics hook for user identification.
 *  If your plugin or integration identifies users or user traits, this is the event to fire on.
 */
'identify',
/**
 * `identifyEnd` - Fires after all registered 'identify' events fire from plugins.
 */
'identifyEnd',
/**
 * `identifyAborted` - Fires if 'track' call is cancelled by a plugin
 */
'identifyAborted',
/**
 * `userIdChanged` - Fires when a user id is updated
 */
'userIdChanged',
/******************
 * Plugin Events
 ******************/

/**
 * `registerPlugins` - Fires when analytics is registering plugins
 */
'registerPlugins',
/**
 * `enablePlugin` - Fires when 'analytics.enablePlugin()' is called
 */
'enablePlugin',
/**
 * `disablePlugin` - Fires when 'analytics.disablePlugin()' is called
 */
'disablePlugin',
/**
 * `loadPlugin` - Fires when 'analytics.loadPlugin()' is called
 */
'loadPlugin',
/******************
 * Browser activity events
 ******************/

/**
 * `online` - Fires when browser network goes online.
 * This fires only when coming back online from an offline state.
 */
'online',
/**
 * `offline` - Fires when browser network goes offline.
 */
'offline',
/******************
 * Storage events
 ******************/

/**
 * `setItemStart` - Fires when analytics.storage.setItem is initialized.
 * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.
 */
'setItemStart',
/**
 * `setItem` - Fires when analytics.storage.setItem is called.
 * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.
 */
'setItem',
/**
 * `setItemEnd` - Fires when setItem storage is complete.
 */
'setItemEnd',
/**
 * `setItemAborted` - Fires when setItem storage is cancelled by a plugin.
 */
'setItemAborted',
/**
 * `removeItemStart` - Fires when analytics.storage.removeItem is initialized.
 * This event gives plugins the ability to intercept removeItem calls and abort / alter them.
 */
'removeItemStart',
/**
 * `removeItem` - Fires when analytics.storage.removeItem is called.
 * This event gives plugins the ability to intercept removeItem calls and abort / alter them.
 */
'removeItem',
/**
 * `removeItemEnd` - Fires when removeItem storage is complete.
 */
'removeItemEnd',
/**
 * `removeItemAborted` - Fires when removeItem storage is cancelled by a plugin.
 */
'removeItemAborted'];
/*!
 * Keys on a plugin that are not considered events
 */

var nonEvents = ['NAMESPACE', 'EVENTS', 'config', 'loaded'];
var pluginEvents = {
  registerPluginType: function registerPluginType(name) {
    return "registerPlugin:".concat(name);
  },
  pluginReadyType: function pluginReadyType(name) {
    return "ready:".concat(name);
  }
};
var EVENTS = coreEvents.reduce(function (acc, curr) {
  acc[curr] = curr;
  return acc;
}, pluginEvents);
function isReservedAction(type) {
  return coreEvents.includes(type);
}

/**
 * Anonymous visitor Id localstorage key
 */
var ANON_ID = '__anon_id';
/**
 * Visitor Id localstorage key
 */

var USER_ID = '__user_id';
/**
 * Visitor traits localstorage key
 */

var USER_TRAITS = '__user_traits';

var constants = /*#__PURE__*/Object.freeze({
  ANON_ID: ANON_ID,
  USER_ID: USER_ID,
  USER_TRAITS: USER_TRAITS
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function initializeMiddleware(instance) {
  return function (store) {
    return function (next) {
      return function (action) {
        if (action.type === EVENTS.bootstrap) {
          /* 1. Set anonymous ID */
          if (!analyticsUtils.storage.getItem(ANON_ID)) {
            instance.storage.setItem(ANON_ID, analyticsUtils.uuid());
          }
          /* 2. Parse url params */


          var params = analyticsUtils.paramsParse();
          var paramsArray = Object.keys(params);

          if (paramsArray.length) {
            var groupedParams = paramsArray.reduce(function (acc, key) {
              // match utm params & dclid (display) & gclid (cpc)
              if (key.match(/^utm_/) || key.match(/^(d|g)clid/)) {
                acc.campaign[key] = params[key];
              }

              if (key.match(/^an_prop_/)) {
                acc.props["".concat(key.replace(/^an_prop_/, ''))] = params[key];
              }

              if (key.match(/^an_trait_/)) {
                acc.traits["".concat(key.replace(/^an_trait_/, ''))] = params[key];
              }

              return acc;
            }, {
              campaign: {},
              props: {},
              traits: {}
            });
            store.dispatch(_objectSpread({
              type: EVENTS.params,
              raw: params
            }, groupedParams));

            if (params.an_uid) {
              // timeout to debounce and make sure integration is registered. Todo refactor
              setTimeout(function () {
                instance.identify(params.an_uid, groupedParams.traits);
              }, 0);
            }

            if (params.an_event) {
              // timeout to debounce and make sure integration is registered. Todo refactor
              setTimeout(function () {
                instance.track(params.an_event, groupedParams.props);
              }, 0);
            } // if url has utm params


            if (Object.keys(groupedParams.campaign).length) {
              store.dispatch({
                type: EVENTS.campaign,
                campaign: groupedParams.campaign
              });
            }

            if (params.an_clean) {
              // timeout to debounce and make sure integration is registered. Todo refactor
              setTimeout(function () {
                analyticsUtils.paramsRemove('an_');
              }, 0);
            }
          }
          /* TODO set these?
          var setFirstVisitDate = function(storage) {
              var now = new Date();
              var year = now.getFullYear().toString();
              var day = now.getDate().toString();
              var month = now.getMonth() + 1;
              if (month < 10) {
                  month = '0' + month.toString();
              }
              var dateString = year + month + day;
               storage.set('firstVisitDate', dateString);
              return dateString;
          }
          var setDaysSinceFirstVisit = function(storage, firstDate) {
              var firstDateISO = firstDate.substring(0, 4) + '-' + firstDate.substring(4, 6) + '-' + firstDate.substring(6);
              var firstDateTime = new Date(firstDateISO)
              var now = new Date();
               var oneDay = 24 * 60 * 60 * 1000;
              var daysSince = Math.round(Math.abs((firstDateTime.getTime() - now.getTime())/(oneDay)));
               return daysSince.toString();
          }
          */

        }

        return next(action);
      };
    };
  };
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
function identifyMiddleware(instance) {
  var storage = instance.storage;
  return function (store) {
    return function (next) {
      return function (action) {
        var userId = action.userId,
            traits = action.traits,
            options = action.options,
            callback = action.callback;

        if (action.type === EVENTS.reset) {
          storage.removeItem(USER_ID);
          storage.removeItem(USER_TRAITS);
          storage.removeItem(ANON_ID);

          if (callback && typeof callback === 'function') {
            callback();
          }
        }

        if (action.type === EVENTS.identify) {
          var currentId = storage.getItem(USER_ID);
          var currentTraits = storage.getItem(USER_TRAITS) || {};

          if (currentId && currentId !== userId) {
            store.dispatch({
              type: EVENTS.userIdChanged,
              old: {
                userId: currentId,
                traits: currentTraits
              },
              "new": {
                userId: userId,
                traits: traits
              },
              options: options // callback: callback

            });
          }

          if (userId) {
            storage.setItem(USER_ID, userId);
          }

          if (traits) {
            storage.setItem(USER_TRAITS, _objectSpread$1({}, currentTraits, {}, traits));
          }
        }

        return next(action);
      };
    };
  };
}

var runtime = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = module.exports;

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);
});

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

var runtimeModule = runtime;

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

var regenerator = runtimeModule;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator = _asyncToGenerator;

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function waitForReady(data, predicate, timeout) {
  return new Promise(function (resolve, reject) {
    if (predicate()) {
      return resolve(data);
    } // Timeout. Add to queue


    if (timeout < 1) {
      return reject(_objectSpread$2({}, data, {
        queue: true
      })); // eslint-disable-line
    } // Else recursive retry


    return pause(10).then(function (_) {
      return waitForReady(data, predicate, timeout - 10).then(resolve, reject);
    });
  });
}

function pause(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function fitlerDisabledPlugins(allPlugins) {
  var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return Object.keys(allPlugins).filter(function (name) {
    var plugins = options.plugins;
    var pluginsFromOpt = plugins || {};

    if (pluginsFromOpt[name] === false) {
      return false;
    } // If enabled by options. Overide settings


    if (pluginsFromOpt[name] === true) {
      return true;
    } // else use state.plugin settings


    if (settings[name] && settings[name].enabled === false) {
      return false;
    }

    return true;
  }).map(function (name) {
    return allPlugins[name];
  });
}

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
function runPlugins (_x, _x2, _x3, _x4, _x5) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = asyncToGenerator(
  /*#__PURE__*/
  regenerator.mark(function _callee(action, getPlugins, instance, store, eventsInfo) {
    var pluginObject, originalType, updatedType, state, activePlugins, allActivePluginKeys, allMatches, actionBefore, activeAndNonAbortedCalls, actionDuring, afterName, actionAfter, cb;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pluginObject = typeof getPlugins === 'function' ? getPlugins() : getPlugins;
            originalType = action.type;
            updatedType = originalType.replace(/Start$/, '');
            /* If action already dispatched exit early. This makes it so plugin methods are not fired twice. */

            if (!(action._ && action._.called)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", action);

          case 5:
            // const actionDepth = (originalType.match(/:/g) || []).length
            // if (actionDepth > 2) {
            //   return action
            // }
            state = instance.getState();
            /* Remove plugins that are disabled by options or by settings */

            activePlugins = fitlerDisabledPlugins(pluginObject, state.plugins, action.options); // console.log('activePlugins', activePlugins)

            allActivePluginKeys = activePlugins.map(function (p) {
              return p.NAMESPACE;
            }); // console.log('allActivePluginKeys', allActivePluginKeys)

            allMatches = getAllMatchingCalls(originalType, activePlugins, pluginObject); // console.log('allMatches', allMatches)

            /* @TODO cache matches and purge on enable/disable/add plugin */

            /**
             * Process all 'actionBefore' hooks
             * Example:
             *  This is processes 'pageStart' methods from plugins and update the event to send through the chain
             */

            _context.next = 11;
            return processEvent({
              action: action,
              data: {
                exact: allMatches.before,
                namespaced: allMatches.beforeNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 11:
            actionBefore = _context.sent;

            if (!shouldAbortAll(actionBefore, allActivePluginKeys.length)) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", actionBefore);

          case 14:
            /* Filter over the plugin method calls and remove aborted plugin by name */
            activeAndNonAbortedCalls = activePlugins.filter(function (plugin) {
              if (shouldAbort(actionBefore, plugin.NAMESPACE)) return false;
              return true;
            }); // console.log(`activeAndNonAbortedCalls ${action.type}`, activeAndNonAbortedCalls)

            if (!(originalType === updatedType)) {
              _context.next = 19;
              break;
            }

            /* If type the same don't double process */
            actionDuring = actionBefore;
            _context.next = 22;
            break;

          case 19:
            _context.next = 21;
            return processEvent({
              action: _objectSpread$3({}, actionBefore, {
                type: updatedType
              }),
              data: {
                exact: allMatches.during,
                namespaced: allMatches.duringNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 21:
            actionDuring = _context.sent;

          case 22:
            if (!originalType.match(/Start$/)) {
              _context.next = 29;
              break;
            }

            afterName = "".concat(updatedType, "End");
            _context.next = 26;
            return processEvent({
              action: _objectSpread$3({}, actionDuring, {
                type: afterName
              }),
              data: {
                exact: allMatches.after,
                namespaced: allMatches.afterNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 26:
            actionAfter = _context.sent;
            // console.log('____ actionAfter', actionAfter)

            /* Fire callback if supplied */
            cb = getCallback(actionAfter);

            if (cb) {
              /** @TODO figure out exact args calls and .on will get */
              cb({
                payload: actionAfter
              }); // eslint-disable-line
            }

          case 29:
            return _context.abrupt("return", actionBefore);

          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}

function getCallback(action) {
  if (!action.meta) return false;
  return Object.keys(action.meta).reduce(function (acc, key) {
    var thing = action.meta[key];
    if (typeof thing === 'function') return thing;
    return acc;
  }, false);
}
/**
 * Async reduce over matched plugin methods
 * Fires plugin functions
 */


function processEvent(_x6) {
  return _processEvent.apply(this, arguments);
}

function _processEvent() {
  _processEvent = asyncToGenerator(
  /*#__PURE__*/
  regenerator.mark(function _callee5(_ref2) {
    var data, action, instance, state, allPlugins, allMatches, store, EVENTS, plugins, context, method, abortable, makeArgs, queueData, payloads, resolvedAction;
    return regenerator.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            data = _ref2.data, action = _ref2.action, instance = _ref2.instance, state = _ref2.state, allPlugins = _ref2.allPlugins, allMatches = _ref2.allMatches, store = _ref2.store, EVENTS = _ref2.EVENTS;
            plugins = state.plugins, context = state.context;
            method = action.type; // console.log(`data ${method}`, data)
            // console.log(`data allMatches ${method}`, allMatches)

            abortable = data.exact.map(function (x) {
              return x.pluginName;
            });
            /* If abort is called from xyzStart */

            if (method.match(/Start$/)) {
              abortable = allMatches.during.map(function (x) {
                return x.pluginName;
              });
            }
            /* make args for functions to concume */


            makeArgs = argumentFactory(instance, abortable); // console.log('makeArgs', makeArgs)

            /* Check if plugin loaded, if not mark action for queue */

            queueData = data.exact.reduce(function (acc, thing) {
              var pluginName = thing.pluginName,
                  methodName = thing.methodName;
              var addToQueue = false; // Queue actions if plugin not loaded except for initialize and reset

              if (!methodName.match(/^initialize/) && !methodName.match(/^reset/)) {
                addToQueue = !plugins[pluginName].loaded;
              }
              /* If offline and its a core method. Add to queue */


              if (context.offline && (methodName.match(/^page/) || methodName.match(/^track/) || methodName.match(/^identify/))) {
                addToQueue = true;
              }

              acc["".concat(pluginName)] = addToQueue;
              return acc;
            }, {});
            /* generate plugin specific payloads */

            _context5.next = 9;
            return data.exact.reduce(
            /*#__PURE__*/
            function () {
              var _ref6 = asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee3(scoped, curr, i) {
                var pluginName, curScope, scopedPayload;
                return regenerator.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        pluginName = curr.pluginName;
                        _context3.next = 3;
                        return scoped;

                      case 3:
                        curScope = _context3.sent;

                        if (!(data.namespaced && data.namespaced[pluginName])) {
                          _context3.next = 11;
                          break;
                        }

                        _context3.next = 7;
                        return data.namespaced[pluginName].reduce(
                        /*#__PURE__*/
                        function () {
                          var _ref7 = asyncToGenerator(
                          /*#__PURE__*/
                          regenerator.mark(function _callee2(acc, p, count) {
                            var curScopeData, genAbort, val, returnValue;
                            return regenerator.wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    genAbort = function _ref8(currentAct, pname, otherPlug) {
                                      return function (reason, plugins) {
                                        var callsite = otherPlug || pname; // console.log(`__abort msg: ${reason}`)
                                        // console.log(`__abort ${pname}`)
                                        // console.log(`__abort xxx: ${plugins}`)
                                        // console.log(`__abort otherPlug`, otherPlug)

                                        return _objectSpread$3({}, currentAct, {
                                          // 🔥 todo verify this merge is ok
                                          abort: {
                                            reason: reason,
                                            plugins: plugins || [pname],
                                            caller: method,
                                            from: callsite
                                          }
                                        });
                                      };
                                    };

                                    _context2.next = 3;
                                    return acc;

                                  case 3:
                                    curScopeData = _context2.sent;

                                    if (!(!p.method || typeof p.method !== 'function')) {
                                      _context2.next = 6;
                                      break;
                                    }

                                    return _context2.abrupt("return", curScopeData);

                                  case 6:
                                    /* Make sure plugins don’t call themselves */
                                    validateMethod(p.methodName, p.pluginName);
                                    _context2.next = 9;
                                    return p.method({
                                      payload: curScopeData,
                                      instance: instance,
                                      abort: genAbort(curScopeData, pluginName, p.pluginName),
                                      config: getConfig(pluginName, plugins, allPlugins),
                                      plugins: plugins
                                    });

                                  case 9:
                                    val = _context2.sent;
                                    returnValue = _typeof_1(val) === 'object' ? val : {};
                                    return _context2.abrupt("return", Promise.resolve(_objectSpread$3({}, curScopeData, {}, returnValue)));

                                  case 12:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function (_x10, _x11, _x12) {
                            return _ref7.apply(this, arguments);
                          };
                        }(), Promise.resolve(action));

                      case 7:
                        scopedPayload = _context3.sent;

                        /* Set scoped payload */
                        curScope[pluginName] = scopedPayload;
                        _context3.next = 12;
                        break;

                      case 11:
                        /* Set payload as default action */
                        curScope[pluginName] = action;

                      case 12:
                        return _context3.abrupt("return", Promise.resolve(curScope));

                      case 13:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x7, _x8, _x9) {
                return _ref6.apply(this, arguments);
              };
            }(), Promise.resolve({}));

          case 9:
            payloads = _context5.sent;
            _context5.next = 12;
            return data.exact.reduce(
            /*#__PURE__*/
            function () {
              var _ref9 = asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee4(promise, curr, i) {
                var lastLoop, pluginName, currentPlugin, currentActionValue, payloadValue, funcArgs, val, returnValue, merged, scopedPayload, nameSpaceEvent, actionDepth;
                return regenerator.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        lastLoop = data.exact.length === i + 1;
                        pluginName = curr.pluginName;
                        currentPlugin = allPlugins[pluginName];
                        _context4.next = 5;
                        return promise;

                      case 5:
                        currentActionValue = _context4.sent;
                        payloadValue = payloads[pluginName] ? payloads[pluginName] : {};

                        if (!shouldAbort(payloadValue, pluginName)) {
                          _context4.next = 10;
                          break;
                        }

                        // console.log(`> Abort from payload specific "${pluginName}" abort value`, payloadValue)
                        abortDispatch({
                          data: payloadValue,
                          method: method,
                          instance: instance,
                          pluginName: pluginName,
                          store: store
                        });
                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 10:
                        if (!shouldAbort(currentActionValue, pluginName)) {
                          _context4.next = 13;
                          break;
                        }

                        // console.log(`> Abort from ${method} abort value`, currentActionValue)
                        if (lastLoop) {
                          abortDispatch({
                            data: currentActionValue,
                            method: method,
                            instance: instance,
                            // pluginName,
                            store: store
                          });
                        }

                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 13:
                        if (!(queueData.hasOwnProperty(pluginName) && queueData[pluginName] === true)) {
                          _context4.next = 16;
                          break;
                        }

                        // console.log('Queue this instead', pluginName)
                        store.dispatch({
                          type: "queue",
                          plugin: pluginName,
                          payload: payloadValue,

                          /* Internal data for analytics engine */
                          _: {
                            called: "queue",
                            from: 'queueMechanism'
                          }
                        });
                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 16:
                        /*
                        const checkForLoaded = () => {
                          const p = instance.getState('plugins')
                          return p[currentPlugin.NAMESPACE].loaded
                        }
                        // const p = instance.getState('plugins')
                        console.log(`loaded "${currentPlugin.NAMESPACE}" > ${method}:`, p[currentPlugin.NAMESPACE].loaded)
                        // await waitForReady(currentPlugin, checkForLoaded, 10000).then((d) => {
                        //   console.log(`Loaded ${method}`, currentPlugin.NAMESPACE)
                        // }).catch((e) => {
                        //   console.log(`Error ${method} ${currentPlugin.NAMESPACE}`, e)
                        //   // TODO dispatch failure
                        // })
                        */
                        // @TODO figure out if we want queuing semantics
                        funcArgs = makeArgs(payloads[pluginName], allPlugins[pluginName]); // console.log(`funcArgs ${method} ${pluginName}`, funcArgs)

                        /* Run the plugin function */

                        _context4.next = 19;
                        return currentPlugin[method]({
                          hello: pluginName,
                          abort: funcArgs.abort,
                          // Send in original action value or scope payload
                          payload: payloads[pluginName],
                          // || currentActionValue,
                          instance: instance,
                          config: getConfig(pluginName, plugins, allPlugins),
                          plugins: plugins
                        });

                      case 19:
                        val = _context4.sent;
                        returnValue = _typeof_1(val) === 'object' ? val : {};
                        merged = _objectSpread$3({}, currentActionValue, {}, returnValue);
                        scopedPayload = payloads[pluginName]; // || currentActionValue

                        if (shouldAbort(scopedPayload, pluginName)) {
                          // console.log(`>> HANDLE abort ${method} ${pluginName}`)
                          abortDispatch({
                            data: scopedPayload,
                            method: method,
                            instance: instance,
                            pluginName: pluginName,
                            store: store
                          });
                        } else {
                          nameSpaceEvent = "".concat(method, ":").concat(pluginName);
                          actionDepth = (nameSpaceEvent.match(/:/g) || []).length;

                          if (actionDepth < 2 && !method.match(/^bootstrap/) && !method.match(/^ready/)) {
                            instance.dispatch(_objectSpread$3({}, scopedPayload, {
                              type: nameSpaceEvent,
                              _: {
                                called: nameSpaceEvent,
                                from: 'submethod'
                              }
                            }));
                          }
                        } // console.log('merged', merged)


                        return _context4.abrupt("return", Promise.resolve(merged));

                      case 25:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x13, _x14, _x15) {
                return _ref9.apply(this, arguments);
              };
            }(), Promise.resolve(action));

          case 12:
            resolvedAction = _context5.sent;

            if (!(!method.match(/Start$/) && !method.match(/^registerPlugin/) && // !method.match(/^disablePlugin/) &&
            // !method.match(/^enablePlugin/) &&
            !method.match(/^ready/) && !method.match(/^bootstrap/) && !method.match(/^params/))) {
              _context5.next = 18;
              break;
            }

            if (EVENTS.plugins.includes(method)) ; // console.log(`Dont dispatch for ${method}`, resolvedAction)
            // return resolvedAction

            /*
            🔥🔥🔥
              Verify this original action setup.
              It's intended to keep actions from double dispatching themselves
            */


            if (!(resolvedAction._ && resolvedAction._.originalAction === method)) {
              _context5.next = 17;
              break;
            }

            return _context5.abrupt("return", resolvedAction);

          case 17:
            store.dispatch(_objectSpread$3({}, resolvedAction, {}, {
              _: {
                originalAction: resolvedAction.type,
                called: resolvedAction.type,
                from: 'engineEnd'
              }
            }));

          case 18:
            return _context5.abrupt("return", resolvedAction);

          case 19:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _processEvent.apply(this, arguments);
}

function abortDispatch(_ref3) {
  var data = _ref3.data,
      method = _ref3.method,
      instance = _ref3.instance,
      pluginName = _ref3.pluginName,
      store = _ref3.store;
  var postFix = pluginName ? ":".concat(pluginName) : '';
  var abortEvent = "".concat(method, "Aborted").concat(postFix);
  store.dispatch(_objectSpread$3({}, data, {
    type: abortEvent,
    _: {
      called: abortEvent,
      from: 'abort'
    }
  }));
}

function getConfig(pluginName, pluginState, allPlugins) {
  if (pluginState[pluginName] && pluginState[pluginName].config) {
    return pluginState[pluginName].config;
  }

  if (allPlugins[pluginName] && allPlugins[pluginName].config) {
    return allPlugins[pluginName].config;
  }

  return {};
}

function getPluginFunctions(methodName, plugins) {
  return plugins.reduce(function (arr, plugin) {
    return !plugin[methodName] ? arr : arr.concat({
      methodName: methodName,
      pluginName: plugin.NAMESPACE,
      method: plugin[methodName]
    });
  }, []);
}

function formatMethod(type) {
  return type.replace(/Start$/, '');
}
/**
 * Return array of event names
 * @param  {String} eventType - original event type
 * @param  {String} namespace - optional namespace postfix
 * @return {[type]}           [description]
 */


function getEventNames(eventType, namespace) {
  var method = formatMethod(eventType);
  var postFix = namespace ? ":".concat(namespace) : ''; // `typeStart:pluginName`

  var type = "".concat(eventType).concat(postFix); // `type:pluginName`

  var methodName = "".concat(method).concat(postFix); // `typeEnd:pluginName`

  var end = "".concat(method, "End").concat(postFix);
  return [type, methodName, end];
}
/* Collect all calls for a given event in the system */


function getAllMatchingCalls(eventType, activePlugins, allPlugins) {
  var eventNames = getEventNames(eventType); // console.log('eventNames', eventNames)
  // 'eventStart', 'event', & `eventEnd`

  var core = eventNames.map(function (word) {
    return getPluginFunctions(word, activePlugins);
  }); // Gather nameSpaced Events

  return activePlugins.reduce(function (acc, plugin) {
    var NAMESPACE = plugin.NAMESPACE;
    var nameSpacedEvents = getEventNames(eventType, NAMESPACE); // console.log('eventNames namespaced', nameSpacedEvents)

    var _nameSpacedEvents$map = nameSpacedEvents.map(function (word) {
      return getPluginFunctions(word, activePlugins);
    }),
        _nameSpacedEvents$map2 = slicedToArray(_nameSpacedEvents$map, 3),
        beforeFuncs = _nameSpacedEvents$map2[0],
        duringFuncs = _nameSpacedEvents$map2[1],
        afterFuncs = _nameSpacedEvents$map2[2];

    if (beforeFuncs.length) {
      acc.beforeNS[NAMESPACE] = beforeFuncs;
    }

    if (duringFuncs.length) {
      acc.duringNS[NAMESPACE] = duringFuncs;
    }

    if (afterFuncs.length) {
      acc.afterNS[NAMESPACE] = afterFuncs;
    }

    return acc;
  }, {
    before: core[0],
    beforeNS: {},
    during: core[1],
    duringNS: {},
    after: core[2],
    afterNS: {}
  });
}

function shouldAbort(_ref4, pluginName) {
  var abort = _ref4.abort;
  if (!abort) return false;
  if (abort === true) return true;
  return includes(abort, pluginName) || abort && includes(abort.plugins, pluginName);
}

function shouldAbortAll(_ref5, pluginsCount) {
  var abort = _ref5.abort;
  if (!abort) return false;
  if (abort === true || typeof abort === 'string') return true;
  var plugins = abort.plugins;
  return isArray(abort) && abort.length === pluginsCount || isArray(plugins) && plugins.length === pluginsCount;
}

function isArray(arr) {
  return Array.isArray(arr);
}

function includes(arr, name) {
  if (!arr || !isArray(arr)) return false;
  return arr.includes(name);
}
/**
 * Generate arguments to pass to plugin methods
 * @param  {Object} instance - analytics instance
 * @param  {[type]} allPlugins [description]
 * @return {[type]}            [description]
 */


function argumentFactory(instance, abortablePlugins) {
  // console.log('abortablePlugins', abortablePlugins)
  return function (action, plugin, otherPlugin) {
    var config = plugin.config,
        NAMESPACE = plugin.NAMESPACE;
    var method = "".concat(NAMESPACE, ".").concat(action.type);

    if (otherPlugin) {
      method = otherPlugin.event;
    }

    var abortF = action.type.match(/Start$/) ? abortFunction(NAMESPACE, method, abortablePlugins, otherPlugin, action) : notAbortableError(action, method);
    return {
      /* self: plugin, for future maybe */
      // clone objects to avoid reassign
      payload: formatPayload(action),
      instance: instance,
      config: config || {},
      abort: abortF
    };
  };
}

function abortFunction(pluginName, method, abortablePlugins, otherPlugin, action) {
  return function (reason, plugins) {
    var caller = otherPlugin ? otherPlugin.NAMESPACE : pluginName;
    var pluginsToAbort = plugins && isArray(plugins) ? plugins : abortablePlugins;

    if (otherPlugin) {
      pluginsToAbort = plugins && isArray(plugins) ? plugins : [pluginName];

      if (!pluginsToAbort.includes(pluginName) || pluginsToAbort.length !== 1) {
        throw new Error("Method \"".concat(method, "\" can only abort \"").concat(pluginName, "\" plugin. ").concat(JSON.stringify(pluginsToAbort), " input valid"));
      }
    }

    return _objectSpread$3({}, action, {
      // 🔥 todo verify this merge is ok
      abort: {
        reason: reason,
        plugins: pluginsToAbort,
        caller: method,
        _: caller
      }
    });
  };
}

function notAbortableError(action, method) {
  return function () {
    throw new Error("Action \"".concat(action.type, "\" is not cancellable. Remove abort call from plugin ").concat(method));
  };
}
/**
 * Verify plugin is not calling itself with whatever:myPluginName self refs
 */


function validateMethod(actionName, pluginName) {
  var text = getNameSpacedAction(actionName);
  var methodCallMatchesPluginNamespace = text && text.name === pluginName;

  if (methodCallMatchesPluginNamespace) {
    var sub = getNameSpacedAction(text.method);
    var subText = sub ? "or \"".concat(sub.method, "\"") : '';
    throw new Error(["Plugin \"".concat(pluginName, "\" is calling method [").concat(actionName, "]"), "Plugins should not call their own namespace.", "Use \"".concat(text.method, "\" ").concat(subText, " in \"").concat(pluginName, "\" plugin instead of \"").concat(actionName, "\"")].join('\n'));
  }
}

function getNameSpacedAction(event) {
  var split = event.match(/(.*):(.*)/);

  if (!split) {
    return false;
  }

  return {
    method: split[1],
    name: split[2]
  };
}

function formatPayload(action) {
  return Object.keys(action).reduce(function (acc, key) {
    // redact type from { payload }
    if (key === 'type') {
      return acc;
    }

    if (_typeof_1(action[key]) === 'object') {
      acc[key] = Object.assign({}, action[key]);
    } else {
      acc[key] = action[key];
    }

    return acc;
  }, {});
}
/*
function getMatchingMethods(eventType, activePlugins) {
  const exact = getPluginFunctions(eventType, activePlugins)
  // console.log('exact', exact)
  // Gather nameSpaced Events
  return activePlugins.reduce((acc, plugin) => {
    const { NAMESPACE } = plugin
    const clean = getPluginFunctions(`${eventType}:${NAMESPACE}`, activePlugins)
    if (clean.length) {
      acc.namespaced[NAMESPACE] = clean
    }
    return acc
  }, {
    exact: exact,
    namespaced: {}
  })
}
*/

function pluginMiddleware(instance, getPlugins, systemEvents) {
  var called = {};
  return function (store) {
    return function (next) {
      return (
        /*#__PURE__*/
        function () {
          var _ref = asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee(action) {
            var type, name, callback, updatedAction, allPlugins, pluginsToLoad, initializeAction, updated, _allPlugins, pluginsArray, allInitialized, completed, failed, allCalls, _updated;

            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    type = action.type, name = action.name, callback = action.callback;
                    updatedAction = action;

                    if (!action.abort) {
                      _context.next = 4;
                      break;
                    }

                    return _context.abrupt("return", next(action));

                  case 4:
                    if (type === EVENTS.disablePlugin || type === EVENTS.enablePlugin) {
                      // TODO run initialize if not loaded
                      if (callback) {
                        callback(name);
                      }
                    }

                    if (!(type === EVENTS.loadPlugin)) {
                      _context.next = 13;
                      break;
                    }

                    // Rerun initialize calls in plugins
                    allPlugins = getPlugins();
                    pluginsToLoad = Object.keys(allPlugins).filter(function (name) {
                      return action.plugins.includes(name);
                    }).reduce(function (acc, curr) {
                      acc[curr] = allPlugins[curr];
                      return acc;
                    }, {});
                    initializeAction = {
                      type: EVENTS.initializeStart,
                      plugins: action.plugins
                    };
                    _context.next = 11;
                    return runPlugins(initializeAction, pluginsToLoad, instance, store, systemEvents);

                  case 11:
                    updated = _context.sent;
                    return _context.abrupt("return", next(updated));

                  case 13:
                    //*  || type.match(/^initializeAbort:/)
                    if (type === EVENTS.initializeEnd) {
                      _allPlugins = getPlugins();
                      pluginsArray = Object.keys(_allPlugins);
                      allInitialized = pluginsArray.filter(function (name) {
                        return action.plugins.includes(name);
                      }).map(function (name) {
                        return _allPlugins[name];
                      });
                      completed = [];
                      failed = [];
                      allCalls = allInitialized.map(function (plugin) {
                        var loaded = plugin.loaded,
                            NAMESPACE = plugin.NAMESPACE;
                        return waitForReady(plugin, loaded, 10000).then(function (d) {
                          if (!called[NAMESPACE]) {
                            // only dispatch namespaced rdy once
                            store.dispatch({
                              type: EVENTS.pluginReadyType(NAMESPACE),
                              // `ready:${NAMESPACE}`
                              name: NAMESPACE,
                              events: Object.keys(plugin).filter(function (name) {
                                return !nonEvents.includes(name);
                              })
                            });
                            called[NAMESPACE] = true;
                          }

                          completed = completed.concat(NAMESPACE); // It's loaded! run the command
                        })["catch"](function (e) {
                          // Timeout Add to queue
                          // console.log('Error generic waitForReady. Push this to queue', e)
                          if (e instanceof Error) {
                            throw new Error(e);
                          }

                          failed = failed.concat(e.NAMESPACE); // Failed to fire, add to queue

                          return e;
                        });
                      });
                      Promise.all(allCalls).then(function (calls) {
                        // setTimeout to ensure runs after 'page'
                        setTimeout(function () {
                          if (pluginsArray.length === allCalls.length) {
                            store.dispatch({
                              type: 'ready',
                              plugins: completed,
                              failed: failed
                            });
                          }
                        }, 0);
                      });
                    }
                    /* New plugin system */


                    if (!(type !== 'bootstrap')) {
                      _context.next = 19;
                      break;
                    }

                    _context.next = 17;
                    return runPlugins(action, getPlugins, instance, store, systemEvents);

                  case 17:
                    _updated = _context.sent;
                    return _context.abrupt("return", next(_updated));

                  case 19:
                    return _context.abrupt("return", next(updatedAction));

                  case 20:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }()
      );
    };
  };
}

function timeStamp() {
  return new Date().getTime();
}

function storageMiddleware() {
  /*
  Todo: emit events for keys we care about
  window.addEventListener('storage', (event) => console.log(event));
  */
  return function (store) {
    return function (next) {
      return function (action) {
        var type = action.type,
            key = action.key,
            value = action.value,
            options = action.options;

        if (type === EVENTS.setItem || type === EVENTS.removeItem) {
          if (action.abort) {
            return next(action);
          } // Run storage set or remove


          if (type === EVENTS.setItem) {
            analyticsUtils.storage.setItem(key, value, options);
          } else {
            analyticsUtils.storage.removeItem(key, options);
          }
        }

        return next(action);
      };
    };
  };
}
var getItem = function getItem(key, opts) {
  return analyticsUtils.storage.getItem(key, opts);
};
var setItem = function setItem(key, value, opts) {
  return {
    type: EVENTS.setItemStart,
    timestamp: timeStamp(),
    key: key,
    value: value,
    options: opts
  };
};
var removeItem = function removeItem(key, opts) {
  return {
    type: EVENTS.removeItemStart,
    timestamp: timeStamp(),
    key: key,
    options: opts
  };
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

/* Class to fix dynamic middlewares from conflicting with each other
if more than one analytic instance is active */

var DynamicMiddleware = function DynamicMiddleware() {
  var _this = this;

  classCallCheck(this, DynamicMiddleware);

  defineProperty(this, "before", []);

  defineProperty(this, "after", []);

  defineProperty(this, "addMiddleware", function (middlewares, position) {
    _this[position] = _this[position].concat(middlewares);
  });

  defineProperty(this, "removeMiddleware", function (middleware, position) {
    var index = _this[position].findIndex(function (d) {
      return d === middleware;
    });

    if (index === -1) return;
    _this[position] = [].concat(toConsumableArray(_this[position].slice(0, index)), toConsumableArray(_this[position].slice(index + 1)));
  });

  defineProperty(this, "resetMiddlewares", function (position) {
    if (!position) {
      _this.before = [];
      _this.after = [];
    } else {
      _this[position] = [];
    }
  });

  defineProperty(this, "dynamicMiddlewares", function (position) {
    return function (store) {
      return function (next) {
        return function (action) {
          var middlewareAPI = {
            getState: store.getState,
            dispatch: function dispatch(act) {
              return store.dispatch(act);
            }
          };

          var chain = _this[position].map(function (middleware) {
            return middleware(middlewareAPI);
          });

          return redux.compose.apply(void 0, toConsumableArray(chain))(next)(action);
        };
      };
    };
  });
};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var initialState = {};

function createReducer(getPlugins) {
  return function plugins() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var newState = {};

    if (action.type === 'initialize:aborted') {
      return state;
    }

    if (/^registerPlugin:([^:]*)$/.test(action.type)) {
      var name = action.type.split(':')[1];
      var pluginInstance = getPlugins()[name];

      if (!pluginInstance || !name) {
        return state;
      }

      newState[name] = {
        enabled: true,

        /* if no initialization method. Set initialized true */
        initialized: pluginInstance.initialize ? false : true,
        // eslint-disable-line
        loaded: Boolean(pluginInstance.loaded()),
        config: pluginInstance.config || {}
      };
      return _objectSpread$4({}, state, {}, newState);
    }

    if (/^initialize:([^:]*)$/.test(action.type)) {
      var _name = action.type.split(':')[1];

      var _pluginInstance = getPlugins()[_name];

      if (!_pluginInstance || !_name) {
        return state;
      }

      newState[_name] = _objectSpread$4({}, state[_name], {}, {
        initialized: true,
        loaded: Boolean(_pluginInstance.loaded())
      });
      return _objectSpread$4({}, state, {}, newState);
    }

    if (/^ready:([^:]*)$/.test(action.type)) {
      // @TODO name missing from this fix
      newState[action.name] = _objectSpread$4({}, state[action.name], {}, {
        loaded: true
      });
      return _objectSpread$4({}, state, {}, newState);
    }

    switch (action.type) {
      /* case EVENTS.pluginFailed:
        // console.log('PLUGIN_FAILED', action.name)
        newState[action.name] = {
          ...state[action.name],
          ...{ loaded: false }
        }
        return { ...state, ...newState }
      */
      case EVENTS.disablePlugin:
        // handle array of integrations ['vanilla', 'google']
        if (Array.isArray(action.name)) {
          newState = action.name.reduce(function (acc, curr) {
            acc[curr] = _objectSpread$4({}, state[curr], {}, {
              enabled: false
            });
            return acc;
          }, state);
          return _objectSpread$4({}, state, {}, newState);
        }

        newState[action.name] = _objectSpread$4({}, state[action.name], {}, {
          enabled: false
        });
        return _objectSpread$4({}, state, {}, newState);

      case EVENTS.enablePlugin:
        // handle array of integrations ['vanilla', 'google']
        if (Array.isArray(action.name)) {
          newState = action.name.reduce(function (acc, curr) {
            acc[curr] = _objectSpread$4({}, state[curr], {}, {
              enabled: true
            });
            return acc;
          }, state);
          return _objectSpread$4({}, state, {}, newState);
        }

        newState[action.name] = _objectSpread$4({}, state[action.name], {}, {
          enabled: true
        });
        return _objectSpread$4({}, state, {}, newState);

      default:
        return state;
    }
  };
}
var enablePlugin = function enablePlugin(name, callback) {
  return {
    type: EVENTS.enablePlugin,
    name: name,
    callback: callback,
    _: {
      originalAction: EVENTS.enablePlugin
    }
  };
};
var disablePlugin = function disablePlugin(name, callback) {
  return {
    type: EVENTS.disablePlugin,
    name: name,
    callback: callback,
    _: {
      originalAction: EVENTS.disablePlugin
    }
  };
};

function getNodeOS() {
  return 'na'; // os.platform()
}

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var osName;
var referrer;
var locale;
var timeZone;

{
  osName = getNodeOS();
  referrer = {};
}

var initialState$1 = {
  initialized: false,
  sessionId: analyticsUtils.uuid(),
  app: null,
  version: null,
  debug: false,
  offline: analyticsUtils.inBrowser ? !navigator.onLine : false,
  // use node network is-online
  os: {
    name: osName
  },
  userAgent: analyticsUtils.inBrowser ? navigator.userAgent : 'node',
  // https://github.com/bestiejs/platform.js
  library: {
    name: 'analytics',
    // TODO fix version number. npm run publish:patch has wrong version
    version: "0.1.15"
  },
  timezone: timeZone,
  locale: locale,
  campaign: {},
  referrer: referrer // ip:
  // context reducer

};
function context() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$1;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var initialized = state.initialized;
  var type = action.type,
      campaign = action.campaign;

  switch (type) {
    case EVENTS.campaign:
      return _objectSpread$5({}, state, {}, {
        campaign: campaign
      });

    case EVENTS.offline:
      return _objectSpread$5({}, state, {}, {
        offline: true
      });

    case EVENTS.online:
      return _objectSpread$5({}, state, {}, {
        offline: false
      });

    default:
      if (!initialized) {
        return _objectSpread$5({}, initialState$1, {}, state, {}, {
          initialized: true
        });
      }

      return state;
  }
} // Pull plugins and reducers off intital config

function makeContext(config) {
  return Object.keys(config).reduce(function (acc, current) {
    if (current === 'plugins' || current === 'reducers') {
      return acc;
    }

    acc[current] = config[current];
    return acc;
  }, {});
}

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function canonicalUrl() {
  if (!analyticsUtils.inBrowser) return;
  var tags = document.getElementsByTagName('link');

  for (var i = 0, tag; tag = tags[i]; i++) {
    if (tag.getAttribute('rel') === 'canonical') {
      return tag.getAttribute('href');
    }
  }
}

function urlPath(url) {
  var regex = /(http[s]?:\/\/)?([^\/\s]+\/)(.*)/g;
  var matches = regex.exec(url);
  var pathMatch = matches && matches[3] ? matches[3].split('?')[0].replace(/#.*$/, '') : '';
  return "/".concat(pathMatch);
}
/**
 * Return the canonical URL and rmove the hash.
 * @param  {string} search - search param
 * @return {string} return current canonical URL
 */


function currentUrl(search) {
  var canonical = canonicalUrl();
  if (!canonical) return window.location.href.replace(/#.*$/, '');
  return canonical.match(/\?/) ? canonical : "".concat(canonical).concat(search);
}

var getPageData = function getPageData() {
  var pageData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!analyticsUtils.inBrowser) return pageData;
  var _document = document,
      title = _document.title,
      referrer = _document.referrer;
  var _window = window,
      location = _window.location,
      innerWidth = _window.innerWidth,
      innerHeight = _window.innerHeight;
  var hash = location.hash,
      search = location.search;
  var url = currentUrl(search);
  var page = {
    title: title,
    url: url,
    path: urlPath(url),
    hash: hash,
    search: search,
    width: innerWidth,
    height: innerHeight
  };

  if (referrer && referrer !== '') {
    page.referrer = referrer;
  }

  return _objectSpread$6({}, page, {}, pageData);
}; // initialState Page Data

var initialState$2 = getPageData(); // page reducer

function page() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$2;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case EVENTS.page:
      return Object.assign({}, state, action.data);

    default:
      return state;
  }
}

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var initialState$3 = {
  event: {},
  lastEvent: null,
  history: [] // track reducer

};
function trackReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$3;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      payload = action.payload,
      options = action.options,
      eventName = action.eventName;

  switch (type) {
    case EVENTS.track:
      return _objectSpread$7({}, state, {}, {
        event: {
          eventName: eventName,
          payload: payload,
          options: options
        },
        lastEvent: action.eventName,
        history: state.history.concat(action)
      });
    // todo push events to history

    default:
      return state;
  }
}

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * TODO figure out if this should live in state...
 *
 * Queue could be in mermory as well.
 *
 * But also needs to be persisted to storage
 */

var initialState$4 = {
  actions: []
};
function queueReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$4;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      data = action.data,
      timestamp = action.timestamp,
      payload = action.payload;

  switch (type) {
    case 'queue':
      var actionChain;
      /* prioritize identify in event queue */

      if (payload && payload.type && payload.type === 'identify') {
        actionChain = [action].concat(state.actions);
      } else {
        actionChain = state.actions.concat(action);
      }

      return _objectSpread$8({}, state, {
        actions: actionChain
      });

    case 'dequeue':
      return [];
    // todo push events to history

    default:
      return state;
  }
}

var context$1 = (typeof self === "undefined" ? "undefined" : _typeof_1(self)) === 'object' && self.self === self && self || // eslint-disable-line
(typeof global === "undefined" ? "undefined" : _typeof_1(global)) === 'object' && global.global === global && global || undefined;

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/* user reducer */

function user() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  // Set anonymousId
  if (action && action.type === EVENTS.setItemEnd && action.key === ANON_ID) {
    return Object.assign({}, state, {
      anonymousId: action.value
    });
  }

  switch (action.type) {
    case EVENTS.identify:
      return Object.assign({}, state, {
        userId: action.userId,
        traits: _objectSpread$9({}, state.traits, {}, action.traits)
      });

    case EVENTS.reset:
      return Object.assign({}, state, {
        userId: null,
        anonymousId: null,
        traits: null
      });

    default:
      return state;
  }
}
var reset = function reset(callback) {
  return {
    type: EVENTS.resetStart,
    timestamp: timeStamp(),
    callback: callback
  };
};
function getPersistedUserData() {
  return {
    userId: analyticsUtils.storage.getItem(USER_ID),
    anonymousId: analyticsUtils.storage.getItem(ANON_ID),
    traits: analyticsUtils.storage.getItem(USER_TRAITS) || {}
  };
}
var tempKey = function tempKey(key) {
  return "__TEMP__".concat(key);
};
function getUserProp(key, instance, payload) {
  /* 1. Try current state */
  var currentId = instance.getState('user')[key];
  if (currentId) return currentId;
  /* 2. Try event payload */

  if (payload && _typeof_1(payload) === 'object' && payload[key]) {
    return payload[key];
  }
  /* 3. Try persisted data */


  var persistedInfo = getPersistedUserData()[key];

  if (persistedInfo) {
    // console.log(`persisted ${key}`, findId)
    return persistedInfo;
  }
  /* 4. Else, try to get in memory placeholder. TODO watch this for future issues */


  if (context$1[tempKey(key)]) {
    return context$1[tempKey(key)];
  }
} // Suggested Traits

/*
{
  address: {
    city: null,
    country: null,
    postalCode: null,
    state: null,
    street: null
  },
  age: 20
  avatar: 'http://url.com/thumbnail.jpg'
  birthday: 122321212,
  createdAt: 1111111,
  description: 'Description of the user',
  email: 'email@email.com',
  firstName: 'david',
  lastName: 'wells',
  name: 'david wells',
  gender: 'male',
  id: 'String Unique ID in your database for a user',
  phone: '727-777-8888',
  title: 'boss ceo',
  username: 'davidwells',
}
*/

function get(obj, key, def, p) {
  p = 0;
  key = key.split ? key.split('.') : key;

  while (obj && p < key.length) {
    obj = obj[key[p++]];
  }

  return obj === undefined || p < key.length ? def : obj;
}

function getCallbackFromArgs() {
  return Array.prototype.slice.call(arguments).reduce(function (acc, arg) {
    if (acc) return acc;

    if (typeof arg === 'function') {
      return arg;
    }

    return acc;
  }, false);
}

function Debug() {
  // initialize global history

  context$1.__ANALYTICS_HISTORY__ = [];
  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var origDispatch = store.dispatch;

      var dispatch = function dispatch(action) {
        var a = action.action || action;

        context$1.__ANALYTICS_HISTORY__.push(a);

        return origDispatch(action);
      };

      return Object.assign(store, {
        dispatch: dispatch
      });
    };
  };
}
function composeWithDebug(config) {
  return function () {
    return redux.compose(redux.compose.apply(null, arguments), Debug(config));
  };
}

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var _setItem = setItem,
    _removeItem = removeItem,
    getItem$1 = getItem;
/**
  * Analytics library configuration
  *
  * After the library is initialized with config, the core API is exposed and ready for use in the application.
  *
  * @param {object} config - analytics core config
  * @param {string} [config.app] - Name of site / app
  * @param {string} [config.version] - Version of your app
  * @param {array}  [config.plugins] - Array of analytics plugins
  * @return {object} Analytics Instance
  * @example
  *
  * import Analytics from 'analytics'
  * import pluginABC from 'analytics-plugin-abc'
  * import pluginXYZ from 'analytics-plugin-xyz'
  *
  * // initialize analytics
  * const analytics = Analytics({
  *   app: 'my-awesome-app',
  *   plugins: [
  *     pluginABC,
  *     pluginXYZ
  *   ]
  * })
  *
  */

function analytics() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var customReducers = config.reducers || {};
  /* Parse plugins array */

  var parsedOptions = (config.plugins || []).reduce(function (acc, p) {
    if (typeof p !== 'function' && p.NAMESPACE) {
      // if plugin exposes EVENTS capture available events
      var definedEvents = p.EVENTS ? Object.keys(p.EVENTS).map(function (k) {
        return p.EVENTS[k];
      }) : []; // Convert available methods into events

      var methodsToEvents = Object.keys(p); // Combine events

      var allEvents = methodsToEvents.concat(definedEvents); // Dedupe events list

      var allEventsUnique = new Set(acc.events.concat(allEvents));
      acc.events = Array.from(allEventsUnique);
      acc.pluginsArray = acc.pluginsArray.concat(p);

      if (acc.plugins[p.NAMESPACE]) {
        throw new Error("Analytics \"".concat(p.NAMESPACE, "\" loaded twice!"));
      }

      acc.plugins[p.NAMESPACE] = p;

      if (!acc.plugins[p.NAMESPACE].loaded) {
        // set default loaded func
        acc.plugins[p.NAMESPACE].loaded = function () {
          return true;
        };
      }

      return acc;
    }
    /* Custom redux middleware */


    acc.middlewares = acc.middlewares.concat(p);
    return acc;
  }, {
    plugins: {},
    pluginsArray: [],
    middlewares: [],
    events: []
  }); // mutable intregrations object for dynamic loading

  var customPlugins = parsedOptions.plugins;
  /* Grab all registered events from plugins loaded */

  var pluginEvents = parsedOptions.events.filter(function (name) {
    return !nonEvents.includes(name);
  });
  var uniqueEvents = new Set(pluginEvents.concat(coreEvents).filter(function (name) {
    return !nonEvents.includes(name);
  }));
  var allSystemEvents = Array.from(uniqueEvents).sort();
  var allPluginEvents = pluginEvents.sort();
  /* plugin methods(functions) must be kept out of state. thus they live here */

  var getPlugins = function getPlugins(asArray) {
    if (asArray) {
      return Object.keys(customPlugins).map(function (plugin) {
        return customPlugins[plugin];
      });
    }

    return customPlugins;
  };

  var _ref = new DynamicMiddleware(),
      addMiddleware = _ref.addMiddleware,
      removeMiddleware = _ref.removeMiddleware,
      dynamicMiddlewares = _ref.dynamicMiddlewares;

  var nonAbortable = function nonAbortable() {
    throw new Error('Abort not allowed from listener');
  };

  var instance = {
    /**
    * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage
    * @param  {String}   userId  - Unique ID of user
    * @param  {Object}   [traits]  - Object of user traits
    * @param  {Object}   [options] - Options to pass to identify call
    * @param  {Function} [callback] - Callback function after identify completes
    * @api public
    *
    * @example
    *
    * // Basic user id identify
    * analytics.identify('xyz-123')
    *
    * // Identify with additional traits
    * analytics.identify('xyz-123', {
    *   name: 'steve',
    *   company: 'hello-clicky'
    * })
    *
    * // Disable identify for specific plugin
    * analytics.identify('xyz-123', {}, {
    *  plugins: {
    *    // disable for segment plugin
    *    segment: false
    *  }
    * })
    *
    * // Fire callback with 2nd or 3rd argument
    * analytics.identify('xyz-123', () => {
    *   console.log('do this after identify')
    * })
    */
    identify: function identify(userId, traits, options, callback) {
      var id = typeof userId === 'string' ? userId : null;
      var data = _typeof_1(userId) === 'object' ? userId : traits;
      var opts = options || {};
      var cb = getCallbackFromArgs(traits, options, callback);
      var user$$1 = instance.user();
      /* sets temporary in memory id. Not to be relied on */

      context$1[tempKey('userId')] = id;
      var resolvedId = id || data.userId || getUserProp('userId', instance, data);
      store.dispatch(_objectSpread$b({
        type: EVENTS.identifyStart,
        userId: resolvedId,
        traits: data || {},
        options: opts,
        anonymousId: user$$1.anonymousId
      }, user$$1.id && user$$1.id !== id && {
        previousId: user$$1.id
      }, {
        meta: _objectSpread$b({
          timestamp: timeStamp()
        }, cb && {
          callback: cb
        })
      }));
    },

    /**
     * Track an analytics event. This will trigger `track` calls in any installed plugins
     * @param  {String}   eventName - Event name
     * @param  {Object}   [payload]   - Event payload
     * @param  {Object}   [options]   - Event options
     * @param  {Function} [callback]  - Callback to fire after tracking completes
     * @api public
     *
     * @example
     *
     * // Basic event tracking
     * analytics.track('buttonClicked')
     *
     * // Event tracking with payload
     * analytics.track('itemPurchased', {
     *   price: 11,
     *   sku: '1234'
     * })
     *
     * // Disable specific plugin on track
     * analytics.track('cartAbandoned', {
     *   items: ['xyz', 'abc']
     * }, {
     *  plugins: {
     *    // disable track event for segment
     *    segment: false
     *  }
     * })
     *
     * // Fire callback with 2nd or 3rd argument
     * analytics.track('newsletterSubscribed', () => {
     *   console.log('do this after track')
     * })
     */
    track: function track(eventName, payload, options, callback) {
      var name = _typeof_1(eventName) === 'object' ? eventName.event : eventName;

      if (!name || typeof name !== 'string') {
        throw new Error('EventName not supplied');
      }

      var data = _typeof_1(eventName) === 'object' ? eventName : payload || {};
      var opts = _typeof_1(options) === 'object' ? options : {};
      var cb = getCallbackFromArgs(payload, options, callback);
      var id = getUserProp('userId', instance, payload);
      var anonId = getUserProp('anonymousId', instance, payload);
      store.dispatch({
        type: EVENTS.trackStart,
        event: name,
        properties: data,
        options: opts,
        userId: id,
        anonymousId: anonId,
        meta: _objectSpread$b({
          timestamp: timeStamp()
        }, cb && {
          callback: cb
        })
      });
    },

    /**
     * Trigger page view. This will trigger `page` calls in any installed plugins
     * @param  {String}   [data] - Page data overrides.
     * @param  {Object}   [options] - Page tracking options
     * @param  {Function} [callback] - Callback to fire after page view call completes
     * @api public
     *
     * @example
     *
     * // Basic page tracking
     * analytics.page()
     *
     * // Page tracking with page data overides
     * analytics.page({
     *   url: 'https://google.com'
     * })
     *
     * // Disable specific plugin page tracking
     * analytics.page({}, {
     *  plugins: {
     *    // disable page tracking event for segment
     *    segment: false
     *  }
     * })
     *
     * // Fire callback with 1st, 2nd or 3rd argument
     * analytics.page(() => {
     *   console.log('do this after page')
     * })
     */
    page: function page$$1(data, options, callback) {
      var d = _typeof_1(data) === 'object' ? data : {};
      var opts = _typeof_1(options) === 'object' ? options : {};
      var cb = getCallbackFromArgs(data, options, callback);
      var userId = getUserProp('userId', instance, d);
      var anonymousId = getUserProp('anonymousId', instance, d);
      store.dispatch({
        type: EVENTS.pageStart,
        properties: getPageData(d),
        options: opts,
        userId: userId,
        anonymousId: anonymousId,
        meta: _objectSpread$b({
          timestamp: timeStamp()
        }, cb && {
          callback: cb
        })
      });
    },

    /**
     * Get user data
     * @param {String} [key] - dot.prop.path of user data. Example: 'traits.company.name'
     * @returns {any} value of user data or null
     *
     * @example
     *
     * // Get all user data
     * const userData = analytics.user()
     *
     * // Get user id
     * const userId = analytics.user('userId')
     *
     * // Get user company name
     * const companyName = analytics.user('traits.company.name')
     */
    user: function user$$1(key) {
      if (key === 'userId' || key === 'id') {
        var findId = getUserProp('userId', instance);
        return findId;
      }

      var user$$1 = instance.getState('user');
      if (!key) return user$$1;
      return get(user$$1, key);
    },

    /**
     * Clear all information about the visitor & reset analytic state.
     * @param {Function} [callback] - Handler to run after reset
     *
     * @example
     *
     * // Reset current visitor
     * analytics.reset()
     */
    reset: function reset$$1(callback) {
      store.dispatch(reset(callback));
    },

    /**
     * Fire callback on analytics ready event
     * @param  {Function} callback - function to trigger when all providers have loaded
     * @returns {Function} - Function to detach listener
     *
     * @example
     *
     * analytics.ready() => {
     *   console.log('all plugins have loaded or were skipped', payload)
     * })
     */
    ready: function ready(callback) {
      return instance.on(EVENTS.ready, callback);
    },

    /**
     * Attach an event handler function for analytics lifecycle events.
     * @param  {String}   name - Name of event to listen to
     * @param  {Function} callback - function to fire on event
     * @return {Function} - Function to detach listener
     *
     * @example
     *
     * // Fire function when 'track' calls happen
     * analytics.on('track', ({ payload }) => {
     *   console.log('track call just happened. Do stuff')
     * })
     *
     * // Remove listener before it is called
     * const removeListener = analytics.on('track', ({ payload }) => {
     *   console.log('This will never get called')
     * })
     *
     * // cleanup .on listener
     * removeListener()
     */
    on: function on(name, callback) {
      if (!name || !callback || typeof callback !== 'function') {
        return false;
      }

      if (name === 'bootstrap') {
        throw new Error("Listeners not allowed for ".concat(name));
      }

      var startRegex = /Start$|Start:/;

      if (name === '*') {
        var beforeHandler = function beforeHandler(store) {
          return function (next) {
            return function (action) {
              if (action.type.match(startRegex)) {
                callback({
                  // eslint-disable-line
                  payload: action,
                  instance: instance,
                  plugins: customPlugins
                });
              }

              return next(action);
            };
          };
        };

        var afterHandler = function afterHandler(store) {
          return function (next) {
            return function (action) {
              if (!action.type.match(startRegex)) {
                callback({
                  // eslint-disable-line
                  payload: action,
                  instance: instance,
                  plugins: customPlugins
                });
              }

              return next(action);
            };
          };
        };

        addMiddleware(beforeHandler, 'before');
        addMiddleware(afterHandler, 'after');
        return function () {
          removeMiddleware(beforeHandler, 'before');
          removeMiddleware(afterHandler, 'after');
        };
      }

      var position = name.match(startRegex) ? 'before' : 'after'; // eslint-disable-line

      var handler = function handler(store) {
        return function (next) {
          return function (action) {
            // Subscribe to EVERYTHING
            if (action.type === name) {
              callback({
                // eslint-disable-line
                payload: action,
                instance: instance,
                plugins: customPlugins,
                abort: nonAbortable
              });
            }
            /* For future matching of event subpaths `track:*` etc
            } else if (name.match(/\*$/)) {
              const match = (name === '*') ? '.' : name
              const regex = new RegExp(`${match}`, 'g')
            } */


            return next(action);
          };
        };
      };

      addMiddleware(handler, position);
      return function () {
        return removeMiddleware(handler, position);
      };
    },

    /**
     * Attach a handler function to an event and only trigger it only once.
     * @param  {String} name - Name of event to listen to
     * @param  {Function} callback - function to fire on event
     * @return {Function} - Function to detach listener
     *
     * @example
     *
     * // Fire function only once 'track'
     * analytics.once('track', ({ payload }) => {
     *   console.log('This will only triggered once when analytics.track() fires')
     * })
     *
     * // Remove listener before it is called
     * const listener = analytics.once('track', ({ payload }) => {
     *   console.log('This will never get called b/c listener() is called')
     * })
     *
     * // cleanup .once listener before it fires
     * listener()
     */
    once: function once(name, callback) {
      if (!name || !callback || typeof callback !== 'function') {
        return false;
      }

      var listener = instance.on(name, function (_ref2) {
        var payload = _ref2.payload;
        callback({
          // eslint-disable-line
          payload: payload,
          instance: instance,
          plugins: customPlugins,
          abort: nonAbortable
        }); // detach listener after its called once

        listener();
      });
      return listener;
    },

    /**
     * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.
     * @param  {string} [key] - dot.prop.path value of state
     * @return {any}
     *
     * @example
     *
     * // Get the current state of analytics
     * analytics.getState()
     *
     * // Get a subpath of state
     * analytics.getState('context.offline')
     */
    getState: function getState(key) {
      var state = store.getState();
      if (key) return get(state, key);
      return Object.assign({}, state);
    },

    /*!
     * Emit events for other plugins or middleware to react to.
     * @param  {Object} action - event to dispatch
     */
    dispatch: function dispatch(action) {
      var actionData = typeof action === 'string' ? {
        type: action
      } : action;

      if (isReservedAction(actionData.type)) {
        throw new Error("Trying to dispatch analytics reservedAction \"".concat(actionData.type, "\""));
      }

      var meta = actionData.meta || {};

      var _private = action._ || {}; // Dispatch actionStart
      // const autoPrefixType = `${theAction.type.replace(/Start$/, '')}Start`


      var dispatchData = _objectSpread$b({}, actionData, {
        meta: _objectSpread$b({
          timestamp: timeStamp()
        }, meta),
        _: _objectSpread$b({
          originalAction: actionData.type
        }, _private) // type: `${autoPrefixType}`

      });

      store.dispatch(dispatchData);
    },

    /**
     * Enable analytics plugin
     * @param  {String|Array} plugins - name of plugins(s) to disable
     * @param  {Function} [callback] - callback after enable runs
     * @example
     *
     * analytics.enablePlugin('google')
     *
     * // Enable multiple plugins at once
     * analytics.enablePlugin(['google', 'segment'])
     */
    enablePlugin: function enablePlugin$$1(plugins, callback) {
      store.dispatch(enablePlugin(plugins, callback));
    },

    /**
     * Disable analytics plugin
     * @param  {String|Array} name - name of integration(s) to disable
     * @param  {Function} callback - callback after disable runs
     * @example
     *
     * analytics.disablePlugin('google')
     *
     * analytics.disablePlugin(['google', 'segment'])
     */
    disablePlugin: function disablePlugin$$1(name, callback) {
      store.dispatch(disablePlugin(name, callback));
    },

    /*!
     * Load registered analytic providers.
     * @param  {String} namespace - integration namespace
     *
     * @example
     * analytics.loadPlugin('segment')
     */
    loadPlugin: function loadPlugin(namespace) {
      store.dispatch({
        type: EVENTS.loadPlugin,
        // Todo handle multiple plugins via array
        plugins: namespace ? [namespace] : Object.keys(getPlugins())
      });
    },

    /**
     * Storage utilities for persisting data.
     * These methods will allow you to save data in localStorage, cookies, or to the window.
     * @type {Object}
     *
     * @example
     *
     * // Pull storage off analytics instance
     * const { storage } = analytics
     *
     * // Get value
     * storage.getItem('storage_key')
     *
     * // Set value
     * storage.setItem('storage_key', 'value')
     *
     * // Remove value
     * storage.removeItem('storage_key')
     */
    storage: {
      /**
       * Get value from storage
       * @param {String} key - storage key
       * @param {Object} [options] - storage options
       * @return {Any}
       *
       * @example
       *
       * analytics.storage.getItem('storage_key')
       */
      getItem: getItem$1,

      /**
       * Set storage value
       * @param {String} key - storage key
       * @param {any} value - storage value
       * @param {Object} [options] - storage options
       *
       * @example
       *
       * analytics.storage.setItem('storage_key', 'value')
       */
      setItem: function setItem$$1(key, value, options) {
        store.dispatch(_setItem(key, value, options));
      },

      /**
       * Remove storage value
       * @param {String} key - storage key
       * @param {Object} [options] - storage options
       *
       * @example
       *
       * analytics.storage.removeItem('storage_key')
       */
      removeItem: function removeItem$$1(key, options) {
        store.dispatch(_removeItem(key, options));
      }
    },

    /*!
     * Set the anonymous ID of the visitor
     * @param {String} anonymousId - anonymous Id to set
     * @param {Object} [options] - storage options
     *
     * @example
     *
     * // Set anonymous ID
     * analytics.setAnonymousId('1234567')
     */
    setAnonymousId: function setAnonymousId(anonymousId, options) {
      instance.storage.setItem(ANON_ID, anonymousId, options);
    },

    /*!
     * Events exposed by core analytics library and all loaded plugins
     * @type {Array}
     */
    events: {
      all: allSystemEvents,
      core: coreEvents,
      plugins: allPluginEvents // byType: (type) => {} @Todo grab logic from engine and give inspectable events

    }
    /* @TODO if it stays, state loaded needs to be set. Re PLUGIN_INIT above
    addPlugin: (newPlugin) => {
      // validate integration
      if (typeof newPlugin !== 'object') {
        return false
      }
      // Set on global integration object
      customPlugins = Object.assign({}, customPlugins, {
        [`${newPlugin.NAMESPACE}`]: newPlugin
      })
      // then add it, and init state key
      store.dispatch({
        type: EVENTS.pluginRegister,
        name: newPlugin.NAMESPACE,
        plugin: newPlugin
      })
    }, */

  };
  var middlewares = parsedOptions.middlewares.concat([
  /* Core analytics middleware */
  dynamicMiddlewares('before'), // Before dynamic middleware <-- fixed pageStart .on listener

  /* Plugin engine */
  pluginMiddleware(instance, getPlugins, {
    all: allSystemEvents,
    plugins: allPluginEvents
  }), storageMiddleware(), initializeMiddleware(instance), identifyMiddleware(instance),
  /* after dynamic middleware */
  dynamicMiddlewares('after')]);
  /* Initial analytics state keys */

  var coreReducers = {
    context: context,
    user: user,
    page: page,
    track: trackReducer,
    plugins: createReducer(getPlugins),
    queue: queueReducer
  };
  var composeEnhancers = redux.compose;
  var composeWithGlobalDebug = redux.compose;

  if (analyticsUtils.inBrowser && config.debug) {
    var devTools = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;

    if (devTools) {
      composeEnhancers = devTools({
        trace: true,
        traceLimit: 25
      });
    }

    composeWithGlobalDebug = function composeWithGlobalDebug() {
      if (arguments.length === 0) return Debug();
      if (_typeof_1(arguments[0]) === 'object') return composeWithDebug(arguments[0]);
      return composeWithDebug().apply(null, arguments);
    };
  }

  var initialConfig = makeContext(config);
  var initialUser = getPersistedUserData(); // console.log('initialUser', initialUser)

  var initialState = {
    context: initialConfig,
    user: initialUser,
    plugins: parsedOptions.pluginsArray.reduce(function (acc, plugin) {
      var NAMESPACE = plugin.NAMESPACE,
          config = plugin.config,
          loaded = plugin.loaded;
      acc[NAMESPACE] = {
        enabled: true,
        // If plugin has no initialize method, set initialized to true
        initialized: !plugin.initialize ? true : false,
        // eslint-disable-line
        loaded: Boolean(loaded()),
        config: config || {}
      };
      return acc;
    }, {}) // Todo allow for more userland defined initial state?

    /* Create analytics store! */

  };
  var store = redux.createStore( // register reducers
  redux.combineReducers(_objectSpread$b({}, coreReducers, {}, customReducers)), // set user defined initial state
  initialState, // register middleware & plugins used
  composeWithGlobalDebug(composeEnhancers(redux.applyMiddleware.apply(void 0, toConsumableArray(middlewares)))));
  /* Synchronously call bootstrap & register Plugin methods */

  var pluginKeys = Object.keys(customPlugins);
  /* Bootstrap analytic plugins */

  store.dispatch({
    type: EVENTS.bootstrap,
    plugins: pluginKeys,
    config: initialConfig
  });
  /* Register analytic plugins */

  store.dispatch({
    type: EVENTS.registerPlugins,
    plugins: pluginKeys
  });
  parsedOptions.pluginsArray.map(function (plugin, i) {
    // eslint-disable-line
    var bootstrap = plugin.bootstrap,
        config = plugin.config;

    if (bootstrap && typeof bootstrap === 'function') {
      bootstrap({
        instance: instance,
        config: config,
        payload: plugin
      });
    }

    var lastCall = createReducer.length === i + 1;
    /* Register plugins */

    store.dispatch({
      type: EVENTS.registerPluginType(plugin.NAMESPACE),
      name: plugin.NAMESPACE,
      plugin: plugin
    });
    /* All plugins registered initialize */

    if (lastCall) {
      store.dispatch({
        type: EVENTS.initializeStart,
        plugins: pluginKeys
      });
    }
  });
  /* Optionally expose redux to instance */


  if (config.exposeRedux) {
    // Add redux methods to instance
    return Object.assign({}, instance, {
      // enables full dispatcher
      dispatch: store.dispatch,
      subscribe: store.subscribe,
      replaceReducer: store.replaceReducer
    });
  }

  return instance;
}

exports.default = analytics;
exports.init = analytics;
exports.Analytics = analytics;
exports.EVENTS = EVENTS;
exports.CONSTANTS = constants;
